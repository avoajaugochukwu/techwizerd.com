[{"content":"This article will cover all the steps and code needed to build a podcast player with React, TailwindCSS, and Apples' podcast API. It is a long one broken into five parts. I hope you are ready to dive in. Introduction React is a user interface framework developed by Facebook. It allows developers to build intuitive websites with rich user interactivity using HTML-like syntax. It also allows modularity, which means you can break code down into manageable modules that makes maintenance of your website easy.\nIn this tutorial, you are going to build a podcast application using React and Apple Podcast API. The application will allow users to browse through all the podcasts available on Apple. When users visit our deployed site, they can choose to listen to the top podcast of the day or use the search functionality that you will develop to search for any podcast of their choice available on Apple Podcast.\nI chose Apple API because it offers a free API with few limitations. While experimenting with the API, I didn\u0026rsquo;t hit the APIs rate limit despite some heavy reloading during the application development. I found that other podcast APIs required creating an account, and they had limited access to their free plans. Meanwhile, with Apple API, you don\u0026rsquo;t need to log in or provide any details, the limits are generous, and no token is required to send requests.\nWho this tutorial is for This tutorial is for intermediate developers, developers who have built a few apps with React and are looking for a comprehensive introduction to some advanced features like debounce, lazy loading, redux (state management), routing, and loading pages dynamically. Newbies can follow along but note that we glazed over details in some parts, including the CSS.\nWhat you will learn In this tutorial you will learn:\n API calls with Axios Debounce React Hooks Responsive web design with Tailwind CSS Reusable React component Using the \u0026lsquo;read more\u0026rsquo; button to hide/show text Using JavaScript Audio API to play sounds in the browser Apple API Infinite scroll, for lazy loading App layout with a fixed sidebar that does not change between renders, improving performance Postman - Calling Apple API from the browser downloads a file that is hard to analyze, but postman has a \u0026ldquo;JSON\u0026rdquo; feature Reverse Proxy to prevent CORS Error React-Redux  Tools you will need  A computer with Node installed. You can download Nodejs from nodejs.org. I will advise you to download version 14+. NPM, a package manager that helps you pull in the various modules needed for our application. A modern code editor. I will recommend visual studio code. It comes with an assortment of extensions to improve the workflow of developers. Heroku account and Heroku CLI. Heroku will host a reverse proxy to prevent CORS issues when you deploy the final application. Create a Heroku account if you don\u0026rsquo;t have one. Then install Heroku CLI, you can install it with NPM, but note that it wouldn\u0026rsquo;t auto-update. Other methods are available. How to install and run the reverse proxy will be discussed later in this tutorial. If you skip this section, you might run into CORS issues. (Optional) Postman, for exploring API queries and viewing the results in your desired format like JSON.  Our approach I will start by creating the structure for the major parts of the project. This will help you focus on functionality down the line. After setting up the project files and folders, I will create the skeleton of the application. Then move on to building the functionalities.\nWhen making changes to files, I will provide the entire code so you don\u0026rsquo;t have to worry about the changes and focus on the tutorial.\nI will also create checkpoints after each part and live code through Codesanbox (where applicable). So that you have something to compare your code to.\nSetting up the React project and files To start the application, open your command-line tool of choice and run:\nnpx create-react-app podcast-player cd podcast-player yarn start The first command takes some time to complete because it downloads files and folders for the project.\nThese commands create the projects' files and folders, change the directory to the just created folder, and then start the application because of the yarn start.\nAt this point, you should see the famous default React app page in the browser at http//:localhost:3000.\nIf you want more details on creating a React app, please look at create-react-app website.\nBuilding the application layout TailwindCSS setup In this tutorial, I don\u0026rsquo;t want to take your time to talk about installing tailwind. And because of the extra work you have to do during deployment. I will copy all the styles needed for this application. Note that tailwind generated them. Tailwind employs a tree shaking technique that only adds the CSS classes used in the application when you build the application with yarn build and yarn build runs when you deploy your application to any of the popular platforms that host React like Heroku, Vercel or Netlify.\n ðŸ”— If you want to install Tailwind for this tutorial, you can find the guide here. However, it is unnecessary for this application.\n  ðŸ”— This is the link to all the CSS files you need for this project. Click on \u0026lsquo;raw\u0026rsquo; and copy the CSS and overwrite the content of the App.css file in the root folder of the application.\n  ðŸ”— You can also get the CSS from the GitHub repo of the first checkpoint. Copy the entire code into the App.css file in the root folder of the application.\n Setup pages or screens React router will handle navigation. React router is a module for React that allows you to navigate our application by mapping URLs to components. It can also handle dynamic URLs, as you would see later.\nThis is the layout of the application: The application will be designed so that the sidebar and the footer will not re-render when the page changes. That means, unlike other apps that apply the React router at the device screen level. This application will use it inside a div or container in the app. In this case, the div that represents \u0026lsquo;Multiple Screens\u0026rsquo; in the image above. The same will apply to the \u0026lsquo;SideBar\u0026rsquo;.\nNow run:\nyarn add react-router-dom This installs react-router-dom which is used for navigation.\nTaking care of images ones and for all ðŸ˜†\n ðŸ”— Download the images used in this project from Dropbox here. Then, click on the download button on the top right to download the images as a zip file and extract it.\n  ðŸ”— View the first checkpoint here. So that you can copy it into your project.\n Create an img folder inside the src folder of the project.\nCopy all the images from the image folder you downloaded and paste them into your newly created img folder.\nThis will ensure that when you flesh out the application, you won\u0026rsquo;t have image related errors.\nSuppose you want to change the favicon (the small image by the left of each website name on your browser\u0026rsquo;s address bar) of your site like mine. Replace the favicon.ico file in the public folder with an .ico file of your choice. Mine will be available in the public folder of the final version of the project.\nCreating the skeleton of the application layout Create a screens folder within src folder.\nAdd 4 new files namely:\n GenreListScreen.jsx HomeScreen.jsx PodcastDetailsScreen.jsx SearchScreen.jsx  Copy the code below the GenreListScreen.jsx\nimport React from \u0026#39;react\u0026#39; const GenreListScreen = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#34;text-white\u0026#34;\u0026gt;GenreListScreen\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default GenreListScreen The code above creates a functional component and adds a simple white text inside it. So that when the routes are configured, you can verify that navigation to the different screens works. Then the export statement makes the component available to be imported in any file that needs it.\nThen repeat the same for the other 3 screen files.\nCopy the code below into the HomeScreen.jsx\nimport React from \u0026#39;react\u0026#39; const HomeScreen = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#34;text-white\u0026#34;\u0026gt;HomeScreen\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default HomeScreen Copy the code below into the PodcastDetailsScreen.jsx\nimport React from \u0026#39;react\u0026#39; const PodcastDetailsScreen = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#34;text-white\u0026#34;\u0026gt;PodcastDetailsScreen\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default PodcastDetailsScreen Copy the code below into the SearchScreen.jsx\nimport React from \u0026#39;react\u0026#39; const SearchScreen = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#34;text-white\u0026#34;\u0026gt;SearchScreen\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } export default SearchScreen Create a components folder.\nAdd 2 new files namely:\n MobileHeader.jsx FooterPlayer.jsx  The MobileHeader will only display on small devices. On small devices, the SideBar disappears. So the application will have a top menu instead of a sidebar on mobile devices.\nThe FooterPlayer is used to show the podcast that is playing. It is static on the page to change pages without losing the ability to pause the currently playing podcast.\n// This component will only show on mobile sized viewports import React from \u0026#39;react\u0026#39; import { Link, NavLink } from \u0026#39;react-router-dom\u0026#39; import logo from \u0026#39;../img/logo.svg\u0026#39; import home_logo from \u0026#39;../img/home_icon.svg\u0026#39; import search_icon from \u0026#39;../img/search_icon_white.svg\u0026#39; const MobileHeader = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;block md:hidden w-full text-white bg-gray-900\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row \u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row py-4\u0026#34;\u0026gt; \u0026lt;img src={logo} alt=\u0026#39;logo\u0026#39; /\u0026gt; \u0026lt;Link className=\u0026#34;text-2xl text-white lg:text-3xl hover:text-gray-100\u0026#34; to=\u0026#34;/\u0026#34;\u0026gt; pplayer \u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;text-left pt-3\u0026#34;\u0026gt; \u0026lt;NavLink className=\u0026#34;flex mx-2 my-1 rounded p-2 px-4 hover:bg-gray-800\u0026#34; activeClassName=\u0026#34;bg-gray-800\u0026#34; exact to=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;img src={home_logo} alt=\u0026#39;home_icon\u0026#39; /\u0026gt; \u0026lt;span className=\u0026#34;ml-4\u0026#34;\u0026gt;Home\u0026lt;/span\u0026gt; \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;text-left pt-3\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NavLink className=\u0026#34;flex mx-2 my-1 rounded p-2 px-4 hover:bg-gray-800\u0026#34; activeClassName=\u0026#34;bg-gray-800\u0026#34; exact to=\u0026#34;/search\u0026#34;\u0026gt; \u0026lt;img src={search_icon} alt=\u0026#39;search_icon\u0026#39; /\u0026gt; \u0026lt;span className=\u0026#34;ml-4\u0026#34;\u0026gt;Search\u0026lt;/span\u0026gt; \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;mt-3 flex flex-col\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;//add link to your github repo\u0026#34; className=\u0026#34;mx-2 text-sm text-gray-600 hover:text-gray-500\u0026#34; aria-label=\u0026#34;GitHub\u0026#34;\u0026gt; Github \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;//add link to your twitter\u0026#34; className=\u0026#34;mx-2 text-sm text-gray-600 hover:text-gray-500\u0026#34; aria-label=\u0026#34;Twitter\u0026#34;\u0026gt; Twitter \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default MobileHeader Don\u0026rsquo;t be intimidated by the code above. TailwindCSS demands plenty of CSS classes.\nLink and NavLink are imported, and Link is react-routers version of your anchor tag in HTML. While NavLink is similar to Link but in addition, it supports an activeClassName attribute that specifies the style of the link when it is active. Then the imported images are placed side-by-side with the navigation links. And an image of the site logo for the homepage link. Remember this is the MobileHeader that is only visible on small-width devices.\nThe other links with anchor tags are external links for you to link your GitHub and Twitter.\nCopy the code below into the FooterPlayer.jsx file.\nimport React from \u0026#39;react\u0026#39; const FooterPlayer = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;fixed left-0 bottom-0 min-w-full z-10\u0026#34; style={{ backgroundColor: \u0026#34;#1a1a1a\u0026#34; }}\u0026gt; \u0026lt;div className=\u0026#34;relative h-full w-full flex\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-white\u0026#34;\u0026gt;FooterPlayer\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default FooterPlayer This code defines a component that is fixed to the bottom of the page and not much for now.\nNext, create a containers folder.\nAdd the new files namlely:\n MainSection.jsx SideBar.jsx  The MainSection file will house all the screens and swap them accordingly when you interact with the application.\nCopy the code below into the MainSection.jsx file\nimport React from \u0026#39;react\u0026#39; import { Switch, Route } from \u0026#39;react-router-dom\u0026#39; import HomeScreen from \u0026#39;../screens/HomeScreen\u0026#39; import SearchScreen from \u0026#39;../screens/SearchScreen\u0026#39; import PodcastDetailsScreen from \u0026#39;../screens/PodcastDetailsScreen\u0026#39; import GenreListScreen from \u0026#39;../screens/GenreListScreen\u0026#39; const MainSection = () =\u0026gt; { return ( \u0026lt;\u0026gt; \u0026lt;main className=\u0026#34; player-section pl-0 md:pl-60 min-h-screen min-w-full\u0026#34;\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34; component={HomeScreen}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route exact path=\u0026#34;/Search\u0026#34; component={SearchScreen}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route exact path=\u0026#34;/podcast/:collectionId\u0026#34; render={(props) =\u0026gt; (\u0026lt;PodcastDetailsScreen {...props} /\u0026gt;)} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/genre/:genreId\u0026#34; component={GenreListScreen}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/\u0026gt; ) } export default MainSection The code above imports some modules from the react-router-dom and also all the screen components. Then all the routes are defined within the Switch. As the name implies, the switch swaps the screens according to the URL the user visits.\nexact is used on all routes to remove ambiguity. The routes for HomeScreen and Search are static. While the routes for PodcastDetailsScreen and GenreListScreen are dynamic because they have to display the podcasts or genres that the user clicks on. The parts with the colon :collectionId and :genreId will be replaced by ids in the actual URL. And those ids can be passed to the PodcastDetailsScreen and GenreListScreen respectively as parameters or props that will query the API for the specific podcast or genre.\nThe collectionId is an alias for the podcast id in Apple Podcast API.\nThe weird-looking render={(props) =\u0026gt; (\u0026lt;PodcastDetailsScreen {...props} /\u0026gt;)} is used to pass down functions that will be created in another part of this tutorial. This Route will be updated later. One of Reacts' superpowers is passing data and functions seamlessly between parents and children components and vice versa.\nBringing it all together with the App.js file Overwrite the App.jsx file with the code below:\nimport React from \u0026#39;react\u0026#39; import { BrowserRouter } from \u0026#39;react-router-dom\u0026#39; import MainSection from \u0026#39;./containers/MainSection\u0026#39; import SideBar from \u0026#39;./containers/SideBar\u0026#39; import MobileHeader from \u0026#39;./components/MobileHeader\u0026#39; import FooterPlayer from \u0026#39;./components/FooterPlayer\u0026#39; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;div\u0026gt; \u0026lt;MobileHeader /\u0026gt; \u0026lt;div className=\u0026#34;flex relative\u0026#34;\u0026gt; \u0026lt;SideBar /\u0026gt; \u0026lt;MainSection /\u0026gt; \u0026lt;FooterPlayer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; As its name implies, this file represents the entire application. Remember, all the screens were imported into the MainSection.jsx file because they will be Switched inside the MainSection component, while the SideBar and FooterPlayer will remain static on the screen between renders. This is not common practice for most applications, but I chose this style because it is fun, and besides, the SideBar contents don\u0026rsquo;t change.\nAll routers must be wrapped in the BrowserRouter which has been done here. A typical react-router code looks like this:\n// Do not copy this, it is an illustration \u0026lt;BrowserRouter\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route ... /\u0026gt; \u0026lt;Route ... /\u0026gt; \u0026lt;Route ... /\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/BrowserRouter\u0026gt; But putting the Switch in a separate file is cleaner.\n Run yarn start in the command line. To see the skeletal representation of the application.\n Checkpoint  ðŸ”— If you encounter any errors, you can find the source code for this first part on GitHub. You can crosscheck with your work to find where you missed something.\n  See a live version of the application so far\n ","permalink":"https://techwizerd.com/posts/how-to-build-a-podcast-player-with-react-js-tailwind-css-and-apple-podcast-api/","summary":"This article will cover all the steps and code needed to build a podcast player with React, TailwindCSS, and Apples' podcast API. It is a long one broken into five parts. I hope you are ready to dive in. Introduction React is a user interface framework developed by Facebook. It allows developers to build intuitive websites with rich user interactivity using HTML-like syntax. It also allows modularity, which means you can break code down into manageable modules that makes maintenance of your website easy.","title":"How to Build a Podcast Player With React Js, Tailwind Css and Apple Podcast API"},{"content":"Introduction This tutorial will walk you through updating your page DOM after an API call, using react hooks.\nIn our example, we would be adding to a list of posts. After a new item is added to the list, we want to trigger react hooks to re-run our fetch API to update the list the user can see. The default behaviour of react useEffect() can lead to an infinite loop, although it is a working solution. But it is not a desirable one.\nRequirements This tutorial requires a basic understanding of the following concepts\n React React Hooks (useEffect(), useState()) Axios API module (fetching and posting data) create-react-app  Let\u0026rsquo;s get started const Posts = () =\u0026gt; { const [posts, setPosts] = useState([]) const baseUrl = 'https://jsonplaceholder.typicode.com/posts/' const getPosts = async () =\u0026gt; { try { const userPosts = await axios.get(baseUrl) setPosts(userPosts.data) } catch (error) { console.error(error.message) } } useEffect(() =\u0026gt; { getPosts() }, []) /* Hook to add post name through API */ const [newPost, setNewPost] = useState({ postName: '' }) const handleChange = (event) =\u0026gt; { setNewPost({ ...newPost, [event.target.name]: event.target.value }) } const handleSubmit = (e) =\u0026gt; { e.preventDefault() const url = baseUrl + 'add/' axios.post(url, { name: newPost.postName, user: 1 }) .then(response =\u0026gt; { console.log(response.data) }) .catch(error =\u0026gt; { console.log(error.response.data) }) e.target.reset() } return ( \u0026lt;div\u0026gt; \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input name=\u0026quot;postName\u0026quot; onChange={handleChange} required /\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Add Post Name\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; {posts.map(post=\u0026gt;( \u0026lt;li key={post.id}\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/div\u0026gt; ) } In the code above, we created a functional component called Posts that fetches and displays data from an API using axios. This component also has a form to add a new post name.\n The problem with this code is that when a new post name is added by axios.post to the database, the user cannot see it immediately. Unless they refresh the page.\n By adding the dependency posts to useEffect(). When a new post name is added, the list will automatically update for the user to see the new post name.\nuseEffect(() =\u0026gt; { getPosts() }, [posts]) The problem with this solution is that if we include a simple console.log('I was hit') in the getPost() method, we will see that the useEffect() runs continuously.\nAdding posts as a dependency leads to an infinite loop, because of the way object reference works in JavaScript. See react useeffect infinite loop.\nThe Solution The ideal solution is to use a dependency that is more predictable, like a simple count. This will be updated only after a successful axios POST request. That is we have successfully added a new post name.\nLet us update our code.\nconst [postLength, setPostLength] = useState(0) #\u0026lt;----new useEffect(() =\u0026gt; { getPosts() }, [postLength]) #\u0026lt;----new And add setCartLength(cartLength + 1) to the successful callback of our API call.\nconst handleSubmit = (e) =\u0026gt; { e.preventDefault() const url = baseUrl + 'add/' axios.post(url, { name: newPost.postName, user: 1 }) .then(response =\u0026gt; { console.log(response.data) setCartLength(cartLength + 1) #\u0026lt;----new }) .catch(error =\u0026gt; { console.log(error.response.data) }) e.target.reset() } What we have done here, is to add a new state called postLength.\nNow the useEffect() will be listening for changes in postLength. And its value changes, only then will getPosts be called again.\nThe API GET request for all posts will only be called again when a new post is added. We ensured that by adding the setCartLength(cartLength + 1) to the successful callback of our API POST request.\nWith this solution, we can update our list after every addition to the list. While avoiding the infinite loop of react useEffect() when using dependencies.\nThis solution can also be extended to other operations like editing or deleting any item in the list. All you have to do is change the state of your dependency after a successful API call.\n","permalink":"https://techwizerd.com/posts/how-to-use-react-use-effect-to-post-data-and-refresh-without-infinite-callback/","summary":"Introduction This tutorial will walk you through updating your page DOM after an API call, using react hooks.\nIn our example, we would be adding to a list of posts. After a new item is added to the list, we want to trigger react hooks to re-run our fetch API to update the list the user can see. The default behaviour of react useEffect() can lead to an infinite loop, although it is a working solution.","title":"How to use React useEffect to post data and refresh without infinite callback"},{"content":"Hugo blog is becoming one of the most popular static site generators.\nThe first time I used it, it blew me away by how easy it was to set up a blog on my local machine. It is also very easy to publish your hugo site to Github Pages for free.\nIn this tutorial, I am going to show you how to set up your Hugo blog on Github Pages. We would be using this theme. You do not need to pay for hosting or provide your credit card details.\nStep 1: Installing Hugo on your windows machine. You can get Hugo by using Chocolatey. Chocolatey is a windows package manager.\nAfter installing Chocolatey. Visit Hugo website, for instructions on how to install Hugo.\nYou can also install it directly from Github. If you do not want to install Chocolatey.\nStep 2: Creating a new project After installing Hugo, type hugo in your cmd to ensure that it is working.\nhugo If it was successfully installed, we can go ahead and start a new site in a directory of your choice.\nhugo new site test.com -f yml This code creates a new site called test and forces it to use yml format for its' config file, which is more readable than toml files. It also creates a folder called test that will house all our Hugo resources.\nYou should see a message like:\nCongratulations! Your new Hugo site is created in C:\\computer\\Hugo\\test.com Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation. Step 3: Add a Hugo theme As discussed earlier, Hugo has a lot of themes that makes development easy. We would use the PaperMod theme.\nRun the following code one after the other in your command prompt.\ncd test.com git init git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 This code changes the directory to test.com. It initializes git in the current folder. And finally pulls the PaperMod theme from Github into the themes/PaperMod folder.\nYour directory should now look like this:\nNext, visit the PaperMod installation page and copy the content of the sample config.yml. Overwrite the original content of the config.yml file, in the root of our test.com folder.\nThen run this in your command prompt.\nhugo server This will start the Hugo server. It will show you the localhost URL to visit where Hugo says the site is running. And you should see this:\nThis is the default home page of the PaperMod theme.\nStep 4: Add pages To add pages.\nRun the command:\nhugo new posts/html.md This creates a new folder called posts and a new markdown file called html.md.\nThe file should have a title, date and draft status.\nChange the draft status to false or delete that line.\nCopy the text below into the html.md file for test purposes.\n  Hypertext Markup Language (HTML) is the standard markup language for documents designed to be displayed in a web browser. It can be assisted by technologies such as Cascading Style Sheets (CSS) and scripting languages such as JavaScript.\n  Run in the command prompt\nhugo server -D The -D flag, tells the server to also show drafts, because our html post has draft set to true. You can set draft to false, or remove that line entirely. Then you do not need the -D flag anymore.\n Note that drafts will not be added to the site when we build it later.\n You should see the first post.\nStep 5: Build Hugo site Before you deploy the site, after making changes. You have to build it. This will convert the markdown files into HTMKL and also creat indexes for the categories. We achieve this by running:\nhugo\nIn the the base folder of the Hugo website.\nAt this point we are ready to move our blog to Github Pages.\nStep 6: Set up repository Firstly, in the config.yml file, add this line publishDir: \u0026quot;docs\u0026quot; after theme: PaperMod. This tells Hugo to publish our site into the directory called docs, when we build.\nThen run:\nhugo -t PaperMod The PaperMod is the name of our theme, if you are using another theme. You would type the name of your theme in its' place.\nThis code builds our site into the docs folder.\nVisit your github profile and create a new repository called test.com.\nFrom our test.com directory on our local machine. Run the following code:\ngit remote add origin \u0026lt;repository URL\u0026gt; git add . git commit -m \u0026quot;Initial Commit\u0026quot; git push origin master This code adds a remote url to our repository, adds and commits our work. Then finally pushes it to our remote repository.\nStep 6: Github Pages From the new repository, click on settings then scroll down to the Github Pages section.\nFor source, select branch as master and change /(root) to docs, then save.\nAfter saving, scroll down back to the Github Ppages section, then copy the new URL that Github has provided. That is where our website is located.\nWe would copy this URL into our config.yml file.\nIn the config.yml file replace the value for baseURL with the github page link we just copied.\nThen run the following code:\ngit add . git commit -m \u0026quot;Updated baseURL\u0026quot; git push origin master This updates the remote repository with our latest changes.\nAt this stage, when you visit the Github Pages URL, you should see the site we just built.\nThat is how we connect Hugo to Github Pages.\nThe benefit is that you can write your posts locally in markdown, and once you push to the remote repository, you website will be updated automatically.\nIf you would like to host your website on your own domain. This link provides instructions on how to achieve that with namecheap web host.\n","permalink":"https://techwizerd.com/posts/how-to-create-hugo-blog-on-github-pages-using-windows/","summary":"Hugo blog is becoming one of the most popular static site generators.\nThe first time I used it, it blew me away by how easy it was to set up a blog on my local machine. It is also very easy to publish your hugo site to Github Pages for free.\nIn this tutorial, I am going to show you how to set up your Hugo blog on Github Pages. We would be using this theme.","title":"How to create Hugo blog on Github Pages Using Windows"}]